{-# LANGUAGE GADTs, KindSignatures, DataKinds #-}
module AbsRelAlgebra (Tree(..), Rels, Rel, Cond, Exp, Projection, Renaming, Aggregation, Function, Distinct, SortExp, Ident, johnMajorEq, module ComposOp) where

import ComposOp

import Data.Monoid


-- Haskell module generated by the BNF converter

data Tag = Rels_ | Rel_ | Cond_ | Exp_ | Projection_ | Renaming_ | Aggregation_ | Function_ | Distinct_ | SortExp_ | Ident_
type Rels = Tree Rels_
type Rel = Tree Rel_
type Cond = Tree Cond_
type Exp = Tree Exp_
type Projection = Tree Projection_
type Renaming = Tree Renaming_
type Aggregation = Tree Aggregation_
type Function = Tree Function_
type Distinct = Tree Distinct_
type SortExp = Tree SortExp_
type Ident = Tree Ident_

data Tree :: Tag -> * where
    RRels :: [Rel] -> Tree Rels_
    RTable :: Ident -> Tree Rel_
    RSelect :: Cond -> Rel -> Tree Rel_
    RProject :: [Projection] -> Rel -> Tree Rel_
    RRename :: Renaming -> Rel -> Tree Rel_
    RGroup :: [Ident] -> [Aggregation] -> Rel -> Tree Rel_
    RSort :: [SortExp] -> Rel -> Tree Rel_
    RDistinct :: Rel -> Tree Rel_
    RUnion :: Rel -> Rel -> Tree Rel_
    RIntersect :: Rel -> Rel -> Tree Rel_
    RCartesian :: Rel -> Rel -> Tree Rel_
    RExcept :: Rel -> Rel -> Tree Rel_
    RNaturalJoin :: Rel -> Rel -> Tree Rel_
    RThetaJoin :: Rel -> Cond -> Rel -> Tree Rel_
    RInnerJoin :: Rel -> [Ident] -> Rel -> Tree Rel_
    RFullOuterJoin :: Rel -> [Ident] -> Rel -> Tree Rel_
    RLeftOuterJoin :: Rel -> [Ident] -> Rel -> Tree Rel_
    RRightOuterJoin :: Rel -> [Ident] -> Rel -> Tree Rel_
    RLet :: Ident -> Rel -> Rel -> Tree Rel_
    CEq :: Exp -> Exp -> Tree Cond_
    CNEq :: Exp -> Exp -> Tree Cond_
    CLt :: Exp -> Exp -> Tree Cond_
    CGt :: Exp -> Exp -> Tree Cond_
    CLeq :: Exp -> Exp -> Tree Cond_
    CGeq :: Exp -> Exp -> Tree Cond_
    CLike :: Exp -> Exp -> Tree Cond_
    CNot :: Cond -> Tree Cond_
    CAnd :: Cond -> Cond -> Tree Cond_
    COr :: Cond -> Cond -> Tree Cond_
    EIdent :: Ident -> Tree Exp_
    EQIdent :: Ident -> Ident -> Tree Exp_
    EString :: String -> Tree Exp_
    EInt :: Integer -> Tree Exp_
    EFloat :: Double -> Tree Exp_
    EAggr :: Function -> Distinct -> Ident -> Tree Exp_
    EMul :: Exp -> Exp -> Tree Exp_
    EDiv :: Exp -> Exp -> Tree Exp_
    ERem :: Exp -> Exp -> Tree Exp_
    EAdd :: Exp -> Exp -> Tree Exp_
    ESub :: Exp -> Exp -> Tree Exp_
    PExp :: Exp -> Tree Projection_
    PRename :: Exp -> Ident -> Tree Projection_
    RRelation :: Ident -> Tree Renaming_
    RAttributes :: Ident -> [Ident] -> Tree Renaming_
    AApp :: Function -> Distinct -> Ident -> Tree Aggregation_
    ARename :: Function -> Distinct -> Ident -> Exp -> Tree Aggregation_
    FAvg :: Tree Function_
    FSum :: Tree Function_
    FMax :: Tree Function_
    FMin :: Tree Function_
    FCount :: Tree Function_
    DNone :: Tree Distinct_
    DDistinct :: Tree Distinct_
    SEAsc :: Exp -> Tree SortExp_
    SEDesc :: Exp -> Tree SortExp_
    Ident :: String -> Tree Ident_

instance Compos Tree where
  compos r a f t = case t of
      RRels rels -> r RRels `a` foldr (a . a (r (:)) . f) (r []) rels
      RTable i -> r RTable `a` f i
      RSelect cond rel -> r RSelect `a` f cond `a` f rel
      RProject projections rel -> r RProject `a` foldr (a . a (r (:)) . f) (r []) projections `a` f rel
      RRename renaming rel -> r RRename `a` f renaming `a` f rel
      RGroup is aggregations rel -> r RGroup `a` foldr (a . a (r (:)) . f) (r []) is `a` foldr (a . a (r (:)) . f) (r []) aggregations `a` f rel
      RSort sortexps rel -> r RSort `a` foldr (a . a (r (:)) . f) (r []) sortexps `a` f rel
      RDistinct rel -> r RDistinct `a` f rel
      RUnion rel0 rel1 -> r RUnion `a` f rel0 `a` f rel1
      RIntersect rel0 rel1 -> r RIntersect `a` f rel0 `a` f rel1
      RCartesian rel0 rel1 -> r RCartesian `a` f rel0 `a` f rel1
      RExcept rel0 rel1 -> r RExcept `a` f rel0 `a` f rel1
      RNaturalJoin rel0 rel1 -> r RNaturalJoin `a` f rel0 `a` f rel1
      RThetaJoin rel0 cond1 rel2 -> r RThetaJoin `a` f rel0 `a` f cond1 `a` f rel2
      RInnerJoin rel0 is1 rel2 -> r RInnerJoin `a` f rel0 `a` foldr (a . a (r (:)) . f) (r []) is1 `a` f rel2
      RFullOuterJoin rel0 is1 rel2 -> r RFullOuterJoin `a` f rel0 `a` foldr (a . a (r (:)) . f) (r []) is1 `a` f rel2
      RLeftOuterJoin rel0 is1 rel2 -> r RLeftOuterJoin `a` f rel0 `a` foldr (a . a (r (:)) . f) (r []) is1 `a` f rel2
      RRightOuterJoin rel0 is1 rel2 -> r RRightOuterJoin `a` f rel0 `a` foldr (a . a (r (:)) . f) (r []) is1 `a` f rel2
      RLet i rel0 rel1 -> r RLet `a` f i `a` f rel0 `a` f rel1
      CEq exp0 exp1 -> r CEq `a` f exp0 `a` f exp1
      CNEq exp0 exp1 -> r CNEq `a` f exp0 `a` f exp1
      CLt exp0 exp1 -> r CLt `a` f exp0 `a` f exp1
      CGt exp0 exp1 -> r CGt `a` f exp0 `a` f exp1
      CLeq exp0 exp1 -> r CLeq `a` f exp0 `a` f exp1
      CGeq exp0 exp1 -> r CGeq `a` f exp0 `a` f exp1
      CLike exp0 exp1 -> r CLike `a` f exp0 `a` f exp1
      CNot cond -> r CNot `a` f cond
      CAnd cond0 cond1 -> r CAnd `a` f cond0 `a` f cond1
      COr cond0 cond1 -> r COr `a` f cond0 `a` f cond1
      EIdent i -> r EIdent `a` f i
      EQIdent i0 i1 -> r EQIdent `a` f i0 `a` f i1
      EAggr function distinct i -> r EAggr `a` f function `a` f distinct `a` f i
      EMul exp0 exp1 -> r EMul `a` f exp0 `a` f exp1
      EDiv exp0 exp1 -> r EDiv `a` f exp0 `a` f exp1
      ERem exp0 exp1 -> r ERem `a` f exp0 `a` f exp1
      EAdd exp0 exp1 -> r EAdd `a` f exp0 `a` f exp1
      ESub exp0 exp1 -> r ESub `a` f exp0 `a` f exp1
      PExp exp -> r PExp `a` f exp
      PRename exp i -> r PRename `a` f exp `a` f i
      RRelation i -> r RRelation `a` f i
      RAttributes i is -> r RAttributes `a` f i `a` foldr (a . a (r (:)) . f) (r []) is
      AApp function distinct i -> r AApp `a` f function `a` f distinct `a` f i
      ARename function distinct i exp -> r ARename `a` f function `a` f distinct `a` f i `a` f exp
      SEAsc exp -> r SEAsc `a` f exp
      SEDesc exp -> r SEDesc `a` f exp
      _ -> r t

instance Show (Tree c) where
  showsPrec n t = case t of
    RRels rels -> opar n . showString "RRels" . showChar ' ' . showsPrec 1 rels . cpar n
    RTable i -> opar n . showString "RTable" . showChar ' ' . showsPrec 1 i . cpar n
    RSelect cond rel -> opar n . showString "RSelect" . showChar ' ' . showsPrec 1 cond . showChar ' ' . showsPrec 1 rel . cpar n
    RProject projections rel -> opar n . showString "RProject" . showChar ' ' . showsPrec 1 projections . showChar ' ' . showsPrec 1 rel . cpar n
    RRename renaming rel -> opar n . showString "RRename" . showChar ' ' . showsPrec 1 renaming . showChar ' ' . showsPrec 1 rel . cpar n
    RGroup is aggregations rel -> opar n . showString "RGroup" . showChar ' ' . showsPrec 1 is . showChar ' ' . showsPrec 1 aggregations . showChar ' ' . showsPrec 1 rel . cpar n
    RSort sortexps rel -> opar n . showString "RSort" . showChar ' ' . showsPrec 1 sortexps . showChar ' ' . showsPrec 1 rel . cpar n
    RDistinct rel -> opar n . showString "RDistinct" . showChar ' ' . showsPrec 1 rel . cpar n
    RUnion rel0 rel1 -> opar n . showString "RUnion" . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 rel1 . cpar n
    RIntersect rel0 rel1 -> opar n . showString "RIntersect" . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 rel1 . cpar n
    RCartesian rel0 rel1 -> opar n . showString "RCartesian" . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 rel1 . cpar n
    RExcept rel0 rel1 -> opar n . showString "RExcept" . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 rel1 . cpar n
    RNaturalJoin rel0 rel1 -> opar n . showString "RNaturalJoin" . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 rel1 . cpar n
    RThetaJoin rel0 cond1 rel2 -> opar n . showString "RThetaJoin" . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 cond1 . showChar ' ' . showsPrec 1 rel2 . cpar n
    RInnerJoin rel0 is1 rel2 -> opar n . showString "RInnerJoin" . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 is1 . showChar ' ' . showsPrec 1 rel2 . cpar n
    RFullOuterJoin rel0 is1 rel2 -> opar n . showString "RFullOuterJoin" . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 is1 . showChar ' ' . showsPrec 1 rel2 . cpar n
    RLeftOuterJoin rel0 is1 rel2 -> opar n . showString "RLeftOuterJoin" . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 is1 . showChar ' ' . showsPrec 1 rel2 . cpar n
    RRightOuterJoin rel0 is1 rel2 -> opar n . showString "RRightOuterJoin" . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 is1 . showChar ' ' . showsPrec 1 rel2 . cpar n
    RLet i rel0 rel1 -> opar n . showString "RLet" . showChar ' ' . showsPrec 1 i . showChar ' ' . showsPrec 1 rel0 . showChar ' ' . showsPrec 1 rel1 . cpar n
    CEq exp0 exp1 -> opar n . showString "CEq" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    CNEq exp0 exp1 -> opar n . showString "CNEq" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    CLt exp0 exp1 -> opar n . showString "CLt" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    CGt exp0 exp1 -> opar n . showString "CGt" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    CLeq exp0 exp1 -> opar n . showString "CLeq" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    CGeq exp0 exp1 -> opar n . showString "CGeq" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    CLike exp0 exp1 -> opar n . showString "CLike" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    CNot cond -> opar n . showString "CNot" . showChar ' ' . showsPrec 1 cond . cpar n
    CAnd cond0 cond1 -> opar n . showString "CAnd" . showChar ' ' . showsPrec 1 cond0 . showChar ' ' . showsPrec 1 cond1 . cpar n
    COr cond0 cond1 -> opar n . showString "COr" . showChar ' ' . showsPrec 1 cond0 . showChar ' ' . showsPrec 1 cond1 . cpar n
    EIdent i -> opar n . showString "EIdent" . showChar ' ' . showsPrec 1 i . cpar n
    EQIdent i0 i1 -> opar n . showString "EQIdent" . showChar ' ' . showsPrec 1 i0 . showChar ' ' . showsPrec 1 i1 . cpar n
    EString str -> opar n . showString "EString" . showChar ' ' . showsPrec 1 str . cpar n
    EInt n -> opar n . showString "EInt" . showChar ' ' . showsPrec 1 n . cpar n
    EFloat d -> opar n . showString "EFloat" . showChar ' ' . showsPrec 1 d . cpar n
    EAggr function distinct i -> opar n . showString "EAggr" . showChar ' ' . showsPrec 1 function . showChar ' ' . showsPrec 1 distinct . showChar ' ' . showsPrec 1 i . cpar n
    EMul exp0 exp1 -> opar n . showString "EMul" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    EDiv exp0 exp1 -> opar n . showString "EDiv" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    ERem exp0 exp1 -> opar n . showString "ERem" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    EAdd exp0 exp1 -> opar n . showString "EAdd" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    ESub exp0 exp1 -> opar n . showString "ESub" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    PExp exp -> opar n . showString "PExp" . showChar ' ' . showsPrec 1 exp . cpar n
    PRename exp i -> opar n . showString "PRename" . showChar ' ' . showsPrec 1 exp . showChar ' ' . showsPrec 1 i . cpar n
    RRelation i -> opar n . showString "RRelation" . showChar ' ' . showsPrec 1 i . cpar n
    RAttributes i is -> opar n . showString "RAttributes" . showChar ' ' . showsPrec 1 i . showChar ' ' . showsPrec 1 is . cpar n
    AApp function distinct i -> opar n . showString "AApp" . showChar ' ' . showsPrec 1 function . showChar ' ' . showsPrec 1 distinct . showChar ' ' . showsPrec 1 i . cpar n
    ARename function distinct i exp -> opar n . showString "ARename" . showChar ' ' . showsPrec 1 function . showChar ' ' . showsPrec 1 distinct . showChar ' ' . showsPrec 1 i . showChar ' ' . showsPrec 1 exp . cpar n
    FAvg -> showString "FAvg"
    FSum -> showString "FSum"
    FMax -> showString "FMax"
    FMin -> showString "FMin"
    FCount -> showString "FCount"
    DNone -> showString "DNone"
    DDistinct -> showString "DDistinct"
    SEAsc exp -> opar n . showString "SEAsc" . showChar ' ' . showsPrec 1 exp . cpar n
    SEDesc exp -> opar n . showString "SEDesc" . showChar ' ' . showsPrec 1 exp . cpar n
    Ident str -> opar n . showString "Ident" . showChar ' ' . showsPrec 1 str . cpar n
   where opar n = if n > 0 then showChar '(' else id
         cpar n = if n > 0 then showChar ')' else id

instance Eq (Tree c) where (==) = johnMajorEq

johnMajorEq :: Tree a -> Tree b -> Bool
johnMajorEq (RRels rels) (RRels rels_) = rels == rels_
johnMajorEq (RTable i) (RTable i_) = i == i_
johnMajorEq (RSelect cond rel) (RSelect cond_ rel_) = cond == cond_ && rel == rel_
johnMajorEq (RProject projections rel) (RProject projections_ rel_) = projections == projections_ && rel == rel_
johnMajorEq (RRename renaming rel) (RRename renaming_ rel_) = renaming == renaming_ && rel == rel_
johnMajorEq (RGroup is aggregations rel) (RGroup is_ aggregations_ rel_) = is == is_ && aggregations == aggregations_ && rel == rel_
johnMajorEq (RSort sortexps rel) (RSort sortexps_ rel_) = sortexps == sortexps_ && rel == rel_
johnMajorEq (RDistinct rel) (RDistinct rel_) = rel == rel_
johnMajorEq (RUnion rel0 rel1) (RUnion rel0_ rel1_) = rel0 == rel0_ && rel1 == rel1_
johnMajorEq (RIntersect rel0 rel1) (RIntersect rel0_ rel1_) = rel0 == rel0_ && rel1 == rel1_
johnMajorEq (RCartesian rel0 rel1) (RCartesian rel0_ rel1_) = rel0 == rel0_ && rel1 == rel1_
johnMajorEq (RExcept rel0 rel1) (RExcept rel0_ rel1_) = rel0 == rel0_ && rel1 == rel1_
johnMajorEq (RNaturalJoin rel0 rel1) (RNaturalJoin rel0_ rel1_) = rel0 == rel0_ && rel1 == rel1_
johnMajorEq (RThetaJoin rel0 cond1 rel2) (RThetaJoin rel0_ cond1_ rel2_) = rel0 == rel0_ && cond1 == cond1_ && rel2 == rel2_
johnMajorEq (RInnerJoin rel0 is1 rel2) (RInnerJoin rel0_ is1_ rel2_) = rel0 == rel0_ && is1 == is1_ && rel2 == rel2_
johnMajorEq (RFullOuterJoin rel0 is1 rel2) (RFullOuterJoin rel0_ is1_ rel2_) = rel0 == rel0_ && is1 == is1_ && rel2 == rel2_
johnMajorEq (RLeftOuterJoin rel0 is1 rel2) (RLeftOuterJoin rel0_ is1_ rel2_) = rel0 == rel0_ && is1 == is1_ && rel2 == rel2_
johnMajorEq (RRightOuterJoin rel0 is1 rel2) (RRightOuterJoin rel0_ is1_ rel2_) = rel0 == rel0_ && is1 == is1_ && rel2 == rel2_
johnMajorEq (RLet i rel0 rel1) (RLet i_ rel0_ rel1_) = i == i_ && rel0 == rel0_ && rel1 == rel1_
johnMajorEq (CEq exp0 exp1) (CEq exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (CNEq exp0 exp1) (CNEq exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (CLt exp0 exp1) (CLt exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (CGt exp0 exp1) (CGt exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (CLeq exp0 exp1) (CLeq exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (CGeq exp0 exp1) (CGeq exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (CLike exp0 exp1) (CLike exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (CNot cond) (CNot cond_) = cond == cond_
johnMajorEq (CAnd cond0 cond1) (CAnd cond0_ cond1_) = cond0 == cond0_ && cond1 == cond1_
johnMajorEq (COr cond0 cond1) (COr cond0_ cond1_) = cond0 == cond0_ && cond1 == cond1_
johnMajorEq (EIdent i) (EIdent i_) = i == i_
johnMajorEq (EQIdent i0 i1) (EQIdent i0_ i1_) = i0 == i0_ && i1 == i1_
johnMajorEq (EString str) (EString str_) = str == str_
johnMajorEq (EInt n) (EInt n_) = n == n_
johnMajorEq (EFloat d) (EFloat d_) = d == d_
johnMajorEq (EAggr function distinct i) (EAggr function_ distinct_ i_) = function == function_ && distinct == distinct_ && i == i_
johnMajorEq (EMul exp0 exp1) (EMul exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (EDiv exp0 exp1) (EDiv exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (ERem exp0 exp1) (ERem exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (EAdd exp0 exp1) (EAdd exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (ESub exp0 exp1) (ESub exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (PExp exp) (PExp exp_) = exp == exp_
johnMajorEq (PRename exp i) (PRename exp_ i_) = exp == exp_ && i == i_
johnMajorEq (RRelation i) (RRelation i_) = i == i_
johnMajorEq (RAttributes i is) (RAttributes i_ is_) = i == i_ && is == is_
johnMajorEq (AApp function distinct i) (AApp function_ distinct_ i_) = function == function_ && distinct == distinct_ && i == i_
johnMajorEq (ARename function distinct i exp) (ARename function_ distinct_ i_ exp_) = function == function_ && distinct == distinct_ && i == i_ && exp == exp_
johnMajorEq FAvg FAvg = True
johnMajorEq FSum FSum = True
johnMajorEq FMax FMax = True
johnMajorEq FMin FMin = True
johnMajorEq FCount FCount = True
johnMajorEq DNone DNone = True
johnMajorEq DDistinct DDistinct = True
johnMajorEq (SEAsc exp) (SEAsc exp_) = exp == exp_
johnMajorEq (SEDesc exp) (SEDesc exp_) = exp == exp_
johnMajorEq (Ident str) (Ident str_) = str == str_
johnMajorEq _ _ = False

instance Ord (Tree c) where
  compare x y = compare (index x) (index y) `mappend` compareSame x y
index :: Tree c -> Int
index (RRels _) = 0
index (RTable _) = 1
index (RSelect _ _) = 2
index (RProject _ _) = 3
index (RRename _ _) = 4
index (RGroup _ _ _) = 5
index (RSort _ _) = 6
index (RDistinct _) = 7
index (RUnion _ _) = 8
index (RIntersect _ _) = 9
index (RCartesian _ _) = 10
index (RExcept _ _) = 11
index (RNaturalJoin _ _) = 12
index (RThetaJoin _ _ _) = 13
index (RInnerJoin _ _ _) = 14
index (RFullOuterJoin _ _ _) = 15
index (RLeftOuterJoin _ _ _) = 16
index (RRightOuterJoin _ _ _) = 17
index (RLet _ _ _) = 18
index (CEq _ _) = 19
index (CNEq _ _) = 20
index (CLt _ _) = 21
index (CGt _ _) = 22
index (CLeq _ _) = 23
index (CGeq _ _) = 24
index (CLike _ _) = 25
index (CNot _) = 26
index (CAnd _ _) = 27
index (COr _ _) = 28
index (EIdent _) = 29
index (EQIdent _ _) = 30
index (EString _) = 31
index (EInt _) = 32
index (EFloat _) = 33
index (EAggr _ _ _) = 34
index (EMul _ _) = 35
index (EDiv _ _) = 36
index (ERem _ _) = 37
index (EAdd _ _) = 38
index (ESub _ _) = 39
index (PExp _) = 40
index (PRename _ _) = 41
index (RRelation _) = 42
index (RAttributes _ _) = 43
index (AApp _ _ _) = 44
index (ARename _ _ _ _) = 45
index (FAvg ) = 46
index (FSum ) = 47
index (FMax ) = 48
index (FMin ) = 49
index (FCount ) = 50
index (DNone ) = 51
index (DDistinct ) = 52
index (SEAsc _) = 53
index (SEDesc _) = 54
index (Ident _) = 55
compareSame :: Tree c -> Tree c -> Ordering
compareSame (RRels rels) (RRels rels_) = compare rels rels_
compareSame (RTable i) (RTable i_) = compare i i_
compareSame (RSelect cond rel) (RSelect cond_ rel_) = mappend (compare cond cond_) (compare rel rel_)
compareSame (RProject projections rel) (RProject projections_ rel_) = mappend (compare projections projections_) (compare rel rel_)
compareSame (RRename renaming rel) (RRename renaming_ rel_) = mappend (compare renaming renaming_) (compare rel rel_)
compareSame (RGroup is aggregations rel) (RGroup is_ aggregations_ rel_) = mappend (compare is is_) (mappend (compare aggregations aggregations_) (compare rel rel_))
compareSame (RSort sortexps rel) (RSort sortexps_ rel_) = mappend (compare sortexps sortexps_) (compare rel rel_)
compareSame (RDistinct rel) (RDistinct rel_) = compare rel rel_
compareSame (RUnion rel0 rel1) (RUnion rel0_ rel1_) = mappend (compare rel0 rel0_) (compare rel1 rel1_)
compareSame (RIntersect rel0 rel1) (RIntersect rel0_ rel1_) = mappend (compare rel0 rel0_) (compare rel1 rel1_)
compareSame (RCartesian rel0 rel1) (RCartesian rel0_ rel1_) = mappend (compare rel0 rel0_) (compare rel1 rel1_)
compareSame (RExcept rel0 rel1) (RExcept rel0_ rel1_) = mappend (compare rel0 rel0_) (compare rel1 rel1_)
compareSame (RNaturalJoin rel0 rel1) (RNaturalJoin rel0_ rel1_) = mappend (compare rel0 rel0_) (compare rel1 rel1_)
compareSame (RThetaJoin rel0 cond1 rel2) (RThetaJoin rel0_ cond1_ rel2_) = mappend (compare rel0 rel0_) (mappend (compare cond1 cond1_) (compare rel2 rel2_))
compareSame (RInnerJoin rel0 is1 rel2) (RInnerJoin rel0_ is1_ rel2_) = mappend (compare rel0 rel0_) (mappend (compare is1 is1_) (compare rel2 rel2_))
compareSame (RFullOuterJoin rel0 is1 rel2) (RFullOuterJoin rel0_ is1_ rel2_) = mappend (compare rel0 rel0_) (mappend (compare is1 is1_) (compare rel2 rel2_))
compareSame (RLeftOuterJoin rel0 is1 rel2) (RLeftOuterJoin rel0_ is1_ rel2_) = mappend (compare rel0 rel0_) (mappend (compare is1 is1_) (compare rel2 rel2_))
compareSame (RRightOuterJoin rel0 is1 rel2) (RRightOuterJoin rel0_ is1_ rel2_) = mappend (compare rel0 rel0_) (mappend (compare is1 is1_) (compare rel2 rel2_))
compareSame (RLet i rel0 rel1) (RLet i_ rel0_ rel1_) = mappend (compare i i_) (mappend (compare rel0 rel0_) (compare rel1 rel1_))
compareSame (CEq exp0 exp1) (CEq exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (CNEq exp0 exp1) (CNEq exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (CLt exp0 exp1) (CLt exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (CGt exp0 exp1) (CGt exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (CLeq exp0 exp1) (CLeq exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (CGeq exp0 exp1) (CGeq exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (CLike exp0 exp1) (CLike exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (CNot cond) (CNot cond_) = compare cond cond_
compareSame (CAnd cond0 cond1) (CAnd cond0_ cond1_) = mappend (compare cond0 cond0_) (compare cond1 cond1_)
compareSame (COr cond0 cond1) (COr cond0_ cond1_) = mappend (compare cond0 cond0_) (compare cond1 cond1_)
compareSame (EIdent i) (EIdent i_) = compare i i_
compareSame (EQIdent i0 i1) (EQIdent i0_ i1_) = mappend (compare i0 i0_) (compare i1 i1_)
compareSame (EString str) (EString str_) = compare str str_
compareSame (EInt n) (EInt n_) = compare n n_
compareSame (EFloat d) (EFloat d_) = compare d d_
compareSame (EAggr function distinct i) (EAggr function_ distinct_ i_) = mappend (compare function function_) (mappend (compare distinct distinct_) (compare i i_))
compareSame (EMul exp0 exp1) (EMul exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (EDiv exp0 exp1) (EDiv exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (ERem exp0 exp1) (ERem exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (EAdd exp0 exp1) (EAdd exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (ESub exp0 exp1) (ESub exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (PExp exp) (PExp exp_) = compare exp exp_
compareSame (PRename exp i) (PRename exp_ i_) = mappend (compare exp exp_) (compare i i_)
compareSame (RRelation i) (RRelation i_) = compare i i_
compareSame (RAttributes i is) (RAttributes i_ is_) = mappend (compare i i_) (compare is is_)
compareSame (AApp function distinct i) (AApp function_ distinct_ i_) = mappend (compare function function_) (mappend (compare distinct distinct_) (compare i i_))
compareSame (ARename function distinct i exp) (ARename function_ distinct_ i_ exp_) = mappend (compare function function_) (mappend (compare distinct distinct_) (mappend (compare i i_) (compare exp exp_)))
compareSame FAvg FAvg = EQ
compareSame FSum FSum = EQ
compareSame FMax FMax = EQ
compareSame FMin FMin = EQ
compareSame FCount FCount = EQ
compareSame DNone DNone = EQ
compareSame DDistinct DDistinct = EQ
compareSame (SEAsc exp) (SEAsc exp_) = compare exp exp_
compareSame (SEDesc exp) (SEDesc exp_) = compare exp exp_
compareSame (Ident str) (Ident str_) = compare str str_
compareSame x y = error "BNFC error:" compareSame
